// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"errors"
	"github.com/speakeasy-sdks/hightouch-go-sdk/pkg/utils"
	"time"
)

type SyncScheduleType string

const (
	SyncScheduleTypeIntervalSchedule   SyncScheduleType = "IntervalSchedule"
	SyncScheduleTypeCronSchedule       SyncScheduleType = "CronSchedule"
	SyncScheduleTypeVisualCronSchedule SyncScheduleType = "VisualCronSchedule"
	SyncScheduleTypeDBTSchedule        SyncScheduleType = "DBTSchedule"
)

type SyncSchedule struct {
	IntervalSchedule   *IntervalSchedule
	CronSchedule       *CronSchedule
	VisualCronSchedule *VisualCronSchedule
	DBTSchedule        *DBTSchedule

	Type SyncScheduleType
}

func CreateSyncScheduleIntervalSchedule(intervalSchedule IntervalSchedule) SyncSchedule {
	typ := SyncScheduleTypeIntervalSchedule

	return SyncSchedule{
		IntervalSchedule: &intervalSchedule,
		Type:             typ,
	}
}

func CreateSyncScheduleCronSchedule(cronSchedule CronSchedule) SyncSchedule {
	typ := SyncScheduleTypeCronSchedule

	return SyncSchedule{
		CronSchedule: &cronSchedule,
		Type:         typ,
	}
}

func CreateSyncScheduleVisualCronSchedule(visualCronSchedule VisualCronSchedule) SyncSchedule {
	typ := SyncScheduleTypeVisualCronSchedule

	return SyncSchedule{
		VisualCronSchedule: &visualCronSchedule,
		Type:               typ,
	}
}

func CreateSyncScheduleDBTSchedule(dbtSchedule DBTSchedule) SyncSchedule {
	typ := SyncScheduleTypeDBTSchedule

	return SyncSchedule{
		DBTSchedule: &dbtSchedule,
		Type:        typ,
	}
}

func (u *SyncSchedule) UnmarshalJSON(data []byte) error {

	intervalSchedule := IntervalSchedule{}
	if err := utils.UnmarshalJSON(data, &intervalSchedule, "", true, true); err == nil {
		u.IntervalSchedule = &intervalSchedule
		u.Type = SyncScheduleTypeIntervalSchedule
		return nil
	}

	cronSchedule := CronSchedule{}
	if err := utils.UnmarshalJSON(data, &cronSchedule, "", true, true); err == nil {
		u.CronSchedule = &cronSchedule
		u.Type = SyncScheduleTypeCronSchedule
		return nil
	}

	visualCronSchedule := VisualCronSchedule{}
	if err := utils.UnmarshalJSON(data, &visualCronSchedule, "", true, true); err == nil {
		u.VisualCronSchedule = &visualCronSchedule
		u.Type = SyncScheduleTypeVisualCronSchedule
		return nil
	}

	dbtSchedule := DBTSchedule{}
	if err := utils.UnmarshalJSON(data, &dbtSchedule, "", true, true); err == nil {
		u.DBTSchedule = &dbtSchedule
		u.Type = SyncScheduleTypeDBTSchedule
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u SyncSchedule) MarshalJSON() ([]byte, error) {
	if u.IntervalSchedule != nil {
		return utils.MarshalJSON(u.IntervalSchedule, "", true)
	}

	if u.CronSchedule != nil {
		return utils.MarshalJSON(u.CronSchedule, "", true)
	}

	if u.VisualCronSchedule != nil {
		return utils.MarshalJSON(u.VisualCronSchedule, "", true)
	}

	if u.DBTSchedule != nil {
		return utils.MarshalJSON(u.DBTSchedule, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

// Schedule - The scheduling configuration. It can be triggerd based on several ways:
//
// Interval: the sync will be trigged based on certain interval(minutes/hours/days/weeks)
//
// Cron: the sync will be trigged based on cron expression https://en.wikipedia.org/wiki/Cron.
//
// Visual: the sync will be trigged based a visual cron configuration on UI
//
// DBT-cloud: the sync will be trigged based on a dbt cloud job
type Schedule struct {
	Schedule SyncSchedule `json:"schedule"`
	Type     string       `json:"type"`
}

func (o *Schedule) GetSchedule() SyncSchedule {
	if o == nil {
		return SyncSchedule{}
	}
	return o.Schedule
}

func (o *Schedule) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

// Sync - Syncs define how data from models are mapped to destinations. Each time a
// sync runs, Hightouch calculates the rows that have changed since the last
// run, and syncs them to Sync's destination.
type Sync struct {
	// The sync's configuration. This specifies how data is mapped, among other
	// configuration.
	//
	// The schema depends on the destination type.
	//
	// Consumers should NOT make assumptions on the contents of the
	// configuration. It may change as Hightouch updates its internal code.
	Configuration map[string]interface{} `json:"configuration"`
	// The timestamp when the sync was created
	CreatedAt time.Time `json:"createdAt"`
	// The id of the Destination that sync is connected to
	DestinationID string `json:"destinationId"`
	// Whether the sync has been disabled by the user.
	Disabled bool `json:"disabled"`
	// The sync's id
	ID string `json:"id"`
	// The timestamp of the last sync run
	LastRunAt *time.Time `json:"lastRunAt"`
	// The id of the Model that sync is connected to
	ModelID string `json:"modelId"`
	// The primary key that sync uses to identify data from source
	PrimaryKey string `json:"primaryKey"`
	// The reference column that sync depends on to sync data from source
	ReferencedColumns []string `json:"referencedColumns"`
	// The scheduling configuration. It can be triggerd based on several ways:
	//
	// Interval: the sync will be trigged based on certain interval(minutes/hours/days/weeks)
	//
	// Cron: the sync will be trigged based on cron expression https://en.wikipedia.org/wiki/Cron.
	//
	// Visual: the sync will be trigged based a visual cron configuration on UI
	//
	// DBT-cloud: the sync will be trigged based on a dbt cloud job
	Schedule *Schedule `json:"schedule"`
	// The sync's slug
	Slug string `json:"slug"`
	// SyncStatus
	Status SyncStatus `json:"status"`
	// The timestamp when the sync was last updated
	UpdatedAt time.Time `json:"updatedAt"`
	// The id of the workspace that the sync belongs to
	WorkspaceID string `json:"workspaceId"`
}

func (s Sync) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Sync) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, true); err != nil {
		return err
	}
	return nil
}

func (o *Sync) GetConfiguration() map[string]interface{} {
	if o == nil {
		return map[string]interface{}{}
	}
	return o.Configuration
}

func (o *Sync) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *Sync) GetDestinationID() string {
	if o == nil {
		return ""
	}
	return o.DestinationID
}

func (o *Sync) GetDisabled() bool {
	if o == nil {
		return false
	}
	return o.Disabled
}

func (o *Sync) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Sync) GetLastRunAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastRunAt
}

func (o *Sync) GetModelID() string {
	if o == nil {
		return ""
	}
	return o.ModelID
}

func (o *Sync) GetPrimaryKey() string {
	if o == nil {
		return ""
	}
	return o.PrimaryKey
}

func (o *Sync) GetReferencedColumns() []string {
	if o == nil {
		return []string{}
	}
	return o.ReferencedColumns
}

func (o *Sync) GetSchedule() *Schedule {
	if o == nil {
		return nil
	}
	return o.Schedule
}

func (o *Sync) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Sync) GetStatus() SyncStatus {
	if o == nil {
		return SyncStatus("")
	}
	return o.Status
}

func (o *Sync) GetUpdatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.UpdatedAt
}

func (o *Sync) GetWorkspaceID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceID
}
